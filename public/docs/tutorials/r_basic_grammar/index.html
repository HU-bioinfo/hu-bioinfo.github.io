<!doctype html><html lang=ja dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Rの基本文法
  #


  プログラミング言語
  #

コンピュータとは文字通り，計算をしてくれる便利な機械です．極端な話，代入と四則演算，制御構文さえあれば，理論上はどんな計算でもできるらしいです．そして，便利な計算は他の誰かがすでに作ってくれてます．(著作権とか権利の問題はあるけどな)
てなわけで，こいつらをうまく組み合わせてやればいいんです．俺らがやる程度のプログラミングつったってやることはそんなとこ．

  変数と代入，そして型
  #

代入なんて，これまでの数学の勉強で耳にタコができるほど聞いてきたと思います．適当な変数に適当な値を入れるあれです．Rではx <- 10みたいに書きます．これで変数xに10が代入されたことを意味します．xに10を代入した状態だとx + 20は30ですね．
代入する時，変数名は数学の解答欄みたいにxといった無味乾燥なものである必要はなく，自由に名付けることができます．原則として，代入するものがなんなのか明示的に命名するのが大事です．例えば，BMIを計算するプログラムを書いているとすると，体重60kgを変数body_weightに代入するとしたら,body_weight <- 60と書くようにします．適切な名前を考えるのはプログラミングをする上で肝中の肝です．ただし，いつくかの単語は予約語といい，プログラミングにおいて特別な意味を持つので，変数として使うことができません．
別にxに代入するのは整数に限らず小数でも，文字列でも，なんでもありです．とはいえなんでもって言われても困るので，そのなんでもについてもう少し詳しく教えます．

  型
  #

変数になんでも入れていいにおけるなんでもとは型といいます．型とは数学における集合のことです．例えば，実数の集合だったり，小数の集合だったりします．なぜ型なんて言い方をするかというと，コンピュータ独特の都合があります．コンピュータの計算資源には限りがあります．いくら実数の集合と言ったって無限に続く数字を扱うのは無理です．コンピュータのストレージに限界が来てしまいます．コンピュータは2進数で計算をしているというのは聞いたことがあると思います．3.14でも0.45でも，ある小数を2進数で表そうとすると，結構な確率で無限に続く小数になってしまいます．そんなわけで，その時々の計算に適した実数の集合(例えば，0から255までという限界を定めた実数の集合)や，小数の集合を型として扱い，計算していきます．また，違う型どうしの計算も面倒臭いです．文字列という型と実数の型の足し算を求めてくださいと言われても困ってしまいます．ある型同士の計算には，それに適した計算，演算が定義されています．
要するに似た性質を持つもの，振る舞いが決まっているものの集合を型とよび，これらを意識してコードを書いていくことになります．自分で型を定義することもできますが，基本となる型を組み合わせることが多く，わざわざ自作せず，出来合いのものを使うのがいいと思います．てなわけで基本的な型を紹介していきます．

  Rにおける具体的な型と演算子
  #

Rは便利なプログラミング言語なので，型といっても厳密なものではなく，ざっくりとした直感的にわかりやすいものになっています．
また，ある型には，それぞれ演算が定義されていると説明しましたが，そのような演算を示す演算子というものがあります．そんな難しいものではないです．足し算という演算における演算子は+です．

  Numeric(数値)型
  #

数値を表す型です．こいつら同士は四則演算ができたりと，皆さんが想像する実数の集合そのものです．実は，さらにinteger(整数)型とdouble(倍精度浮動小数点, 要するに小数)型に分けることができますが別に無視でもいいです．
この型に定義されている演算は以下のとおりです．ちなみに，この演算子らを算術演算子といいます．(名前はいちいち覚えなくていいです)

  
      
          演算子
          意味
          コード例
          結果
      
  
  
      
          +
          和
          3 + 6
          9
      
      
          -
          差
          4 - 1
          3
      
      
          *
          積
          19 * 8
          152
      
      
          /
          商
          9 / 2
          4.5
      
      
          %/%
          整数商 (あまりを無視した商)
          9 %/% 2
          4
      
      
          %%
          剰余 (余り)
          9 %% 2
          1
      
      
          ^
          累乗
          2^4
          16
      
  

また，これら値同士を比較する比較演算子というものもあり，これらの演算の結果，後述するLogical型の値を返します"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://hu-bioinfo.github.io/docs/tutorials/r_basic_grammar/"><meta property="og:site_name" content="北海道大学医学部 Bioinfo研究会"><meta property="og:title" content="R Basic Grammar"><meta property="og:description" content="Rの基本文法 # プログラミング言語 # コンピュータとは文字通り，計算をしてくれる便利な機械です．極端な話，代入と四則演算，制御構文さえあれば，理論上はどんな計算でもできるらしいです．そして，便利な計算は他の誰かがすでに作ってくれてます．(著作権とか権利の問題はあるけどな)
てなわけで，こいつらをうまく組み合わせてやればいいんです．俺らがやる程度のプログラミングつったってやることはそんなとこ．
変数と代入，そして型 # 代入なんて，これまでの数学の勉強で耳にタコができるほど聞いてきたと思います．適当な変数に適当な値を入れるあれです．Rではx <- 10みたいに書きます．これで変数xに10が代入されたことを意味します．xに10を代入した状態だとx + 20は30ですね．
代入する時，変数名は数学の解答欄みたいにxといった無味乾燥なものである必要はなく，自由に名付けることができます．原則として，代入するものがなんなのか明示的に命名するのが大事です．例えば，BMIを計算するプログラムを書いているとすると，体重60kgを変数body_weightに代入するとしたら,body_weight <- 60と書くようにします．適切な名前を考えるのはプログラミングをする上で肝中の肝です．ただし，いつくかの単語は予約語といい，プログラミングにおいて特別な意味を持つので，変数として使うことができません．
別にxに代入するのは整数に限らず小数でも，文字列でも，なんでもありです．とはいえなんでもって言われても困るので，そのなんでもについてもう少し詳しく教えます．
型 # 変数になんでも入れていいにおけるなんでもとは型といいます．型とは数学における集合のことです．例えば，実数の集合だったり，小数の集合だったりします．なぜ型なんて言い方をするかというと，コンピュータ独特の都合があります．コンピュータの計算資源には限りがあります．いくら実数の集合と言ったって無限に続く数字を扱うのは無理です．コンピュータのストレージに限界が来てしまいます．コンピュータは2進数で計算をしているというのは聞いたことがあると思います．3.14でも0.45でも，ある小数を2進数で表そうとすると，結構な確率で無限に続く小数になってしまいます．そんなわけで，その時々の計算に適した実数の集合(例えば，0から255までという限界を定めた実数の集合)や，小数の集合を型として扱い，計算していきます．また，違う型どうしの計算も面倒臭いです．文字列という型と実数の型の足し算を求めてくださいと言われても困ってしまいます．ある型同士の計算には，それに適した計算，演算が定義されています．
要するに似た性質を持つもの，振る舞いが決まっているものの集合を型とよび，これらを意識してコードを書いていくことになります．自分で型を定義することもできますが，基本となる型を組み合わせることが多く，わざわざ自作せず，出来合いのものを使うのがいいと思います．てなわけで基本的な型を紹介していきます．
Rにおける具体的な型と演算子 # Rは便利なプログラミング言語なので，型といっても厳密なものではなく，ざっくりとした直感的にわかりやすいものになっています．
また，ある型には，それぞれ演算が定義されていると説明しましたが，そのような演算を示す演算子というものがあります．そんな難しいものではないです．足し算という演算における演算子は+です．
Numeric(数値)型 # 数値を表す型です．こいつら同士は四則演算ができたりと，皆さんが想像する実数の集合そのものです．実は，さらにinteger(整数)型とdouble(倍精度浮動小数点, 要するに小数)型に分けることができますが別に無視でもいいです．
この型に定義されている演算は以下のとおりです．ちなみに，この演算子らを算術演算子といいます．(名前はいちいち覚えなくていいです)
演算子 意味 コード例 結果 + 和 3 + 6 9 - 差 4 - 1 3 * 積 19 * 8 152 / 商 9 / 2 4.5 %/% 整数商 (あまりを無視した商) 9 %/% 2 4 %% 剰余 (余り) 9 %% 2 1 ^ 累乗 2^4 16 また，これら値同士を比較する比較演算子というものもあり，これらの演算の結果，後述するLogical型の値を返します"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>R Basic Grammar | 北海道大学医学部 Bioinfo研究会</title>
<link rel=icon href=https://hu-bioinfo.github.io/favicon.png><link rel=manifest href=https://hu-bioinfo.github.io/manifest.json><link rel=canonical href=https://hu-bioinfo.github.io/docs/tutorials/r_basic_grammar/><link rel=stylesheet href=https://hu-bioinfo.github.io/book.min.434035e7885c7f5d12818bd9f111cf1a0925c6fb78382667381c3d5eda3fb4f1.css integrity="sha256-Q0A154hcf10SgYvZ8RHPGgklxvt4OCZnOBw9Xto/tPE=" crossorigin=anonymous><script defer src=https://hu-bioinfo.github.io/fuse.min.js></script><script defer src=https://hu-bioinfo.github.io/ja.search.min.7a2bfcf6c9d4c3bb317993ee62d8b3e16d70331fb5b49cd076a1e8a3ee86aa89.js integrity="sha256-eiv89snUw7sxeZPuYtiz4W1wMx+1tJzQdqHoo+6Gqok=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=https://hu-bioinfo.github.io/><span>北海道大学医学部 Bioinfo研究会</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><input type=checkbox id=section-19e3ab56062efc00dcb4ec4cfb280452 class=toggle checked>
<label for=section-19e3ab56062efc00dcb4ec4cfb280452 class="flex justify-between"><a href=https://hu-bioinfo.github.io/docs/tutorials/>Tutorials</a></label><ul><li><a href=https://hu-bioinfo.github.io/docs/tutorials/linux-command/>linux-command</a></li><li><a href=https://hu-bioinfo.github.io/docs/tutorials/r_basic_grammar/ class=active>R Basic Grammar</a></li><li><a href=https://hu-bioinfo.github.io/docs/tutorials/tidyverse/>Tidyverse</a></li><li><a href=https://hu-bioinfo.github.io/docs/tutorials/ggplot2/>ggplot2</a></li><li><a href=https://hu-bioinfo.github.io/docs/tutorials/example/>Example</a></li></ul></li><li><a href=https://hu-bioinfo.github.io/docs/about/>About</a></li><li><a href=https://hu-bioinfo.github.io/docs/members/>Members</a></li><li><a href=https://hu-bioinfo.github.io/docs/how_to_write_articles/>How to Write Articles</a></li></ul><ul><li><a href=https://github.com/HU-bioinfo/ target=_blank rel=noopener>Github</a></li><li><a href=https://x.com/hokudaiBioinfo target=_blank rel=noopener>X</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://hu-bioinfo.github.io/svg/menu.svg class=book-icon alt=Menu></label><h3>R Basic Grammar</h3><label for=toc-control><img src=https://hu-bioinfo.github.io/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#プログラミング言語>プログラミング言語</a></li><li><a href=#変数と代入そして型>変数と代入，そして型</a></li><li><a href=#型>型</a></li><li><a href=#rにおける具体的な型と演算子>Rにおける具体的な型と演算子</a><ul><li><a href=#numeric数値型>Numeric(数値)型</a></li><li><a href=#logicalbool-論理型>Logical(bool, 論理)型</a></li><li><a href=#characterstring-文字列型>Character(String, 文字列)型</a></li><li><a href=#factor因子型>Factor(因子)型</a></li><li><a href=#function関数型>Function(関数)型</a></li></ul></li><li><a href=#データ構造>データ構造</a><ul><li><a href=#vectorベクター>Vector(ベクター)</a></li><li><a href=#dataframeデータフレーム>Dataframe(データフレーム)</a></li><li><a href=#listリスト>List(リスト)</a></li><li><a href=#tibble型>tibble型</a></li></ul></li><li><a href=#制御構文>制御構文</a><ul><li><a href=#条件分岐>条件分岐</a></li><li><a href=#反復処理ループ処理>反復処理(ループ処理)</a></li></ul></li><li><a href=#関数>関数</a></li><li><a href=#予約語>予約語</a></li><li><a href=#コメントアウト>コメントアウト</a></li><li><a href=#パッケージ>パッケージ</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=rの基本文法>Rの基本文法
<a class=anchor href=#r%e3%81%ae%e5%9f%ba%e6%9c%ac%e6%96%87%e6%b3%95>#</a></h1><h2 id=プログラミング言語>プログラミング言語
<a class=anchor href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e8%a8%80%e8%aa%9e>#</a></h2><p>コンピュータとは文字通り，計算をしてくれる便利な機械です．極端な話，代入と四則演算，制御構文さえあれば，理論上はどんな計算でもできるらしいです．そして，便利な計算は他の誰かがすでに作ってくれてます．(著作権とか権利の問題はあるけどな)</p><p>てなわけで，こいつらをうまく組み合わせてやればいいんです．俺らがやる程度のプログラミングつったってやることはそんなとこ．</p><h2 id=変数と代入そして型>変数と代入，そして型
<a class=anchor href=#%e5%a4%89%e6%95%b0%e3%81%a8%e4%bb%a3%e5%85%a5%e3%81%9d%e3%81%97%e3%81%a6%e5%9e%8b>#</a></h2><p>代入なんて，これまでの数学の勉強で耳にタコができるほど聞いてきたと思います．適当な変数に適当な値を入れるあれです．Rでは<code>x &lt;- 10</code>みたいに書きます．これで変数<code>x</code>に10が代入されたことを意味します．<code>x</code>に10を代入した状態だと<code>x + 20</code>は30ですね．</p><p>代入する時，変数名は数学の解答欄みたいに<code>x</code>といった無味乾燥なものである必要はなく，自由に名付けることができます．原則として，代入するものがなんなのか明示的に命名するのが大事です．例えば，BMIを計算するプログラムを書いているとすると，体重60kgを変数<code>body_weight</code>に代入するとしたら,<code>body_weight &lt;- 60</code>と書くようにします．適切な名前を考えるのはプログラミングをする上で肝中の肝です．ただし，いつくかの単語は予約語といい，プログラミングにおいて特別な意味を持つので，変数として使うことができません．</p><p>別に<code>x</code>に代入するのは整数に限らず小数でも，文字列でも，なんでもありです．とはいえなんでもって言われても困るので，そのなんでもについてもう少し詳しく教えます．</p><h2 id=型>型
<a class=anchor href=#%e5%9e%8b>#</a></h2><p><code>変数になんでも入れていい</code>における<code>なんでも</code>とは型といいます．型とは数学における集合のことです．例えば，実数の集合だったり，小数の集合だったりします．なぜ型なんて言い方をするかというと，コンピュータ独特の都合があります．コンピュータの計算資源には限りがあります．いくら実数の集合と言ったって無限に続く数字を扱うのは無理です．コンピュータのストレージに限界が来てしまいます．コンピュータは2進数で計算をしているというのは聞いたことがあると思います．3.14でも0.45でも，ある小数を2進数で表そうとすると，結構な確率で無限に続く小数になってしまいます．そんなわけで，その時々の計算に適した実数の集合(例えば，0から255までという限界を定めた実数の集合)や，小数の集合を型として扱い，計算していきます．また，違う型どうしの計算も面倒臭いです．文字列という型と実数の型の足し算を求めてくださいと言われても困ってしまいます．ある型同士の計算には，それに適した計算，演算が定義されています．</p><p>要するに似た性質を持つもの，振る舞いが決まっているものの集合を型とよび，これらを意識してコードを書いていくことになります．自分で型を定義することもできますが，基本となる型を組み合わせることが多く，わざわざ自作せず，出来合いのものを使うのがいいと思います．てなわけで基本的な型を紹介していきます．</p><h2 id=rにおける具体的な型と演算子>Rにおける具体的な型と演算子
<a class=anchor href=#r%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e5%85%b7%e4%bd%93%e7%9a%84%e3%81%aa%e5%9e%8b%e3%81%a8%e6%bc%94%e7%ae%97%e5%ad%90>#</a></h2><p>Rは便利なプログラミング言語なので，型といっても厳密なものではなく，ざっくりとした直感的にわかりやすいものになっています．</p><p>また，ある型には，それぞれ演算が定義されていると説明しましたが，そのような演算を示す演算子というものがあります．そんな難しいものではないです．足し算という演算における演算子は<code>+</code>です．</p><h3 id=numeric数値型>Numeric(数値)型
<a class=anchor href=#numeric%e6%95%b0%e5%80%a4%e5%9e%8b>#</a></h3><p>数値を表す型です．こいつら同士は四則演算ができたりと，皆さんが想像する実数の集合そのものです．実は，さらにinteger(整数)型とdouble(倍精度浮動小数点, 要するに小数)型に分けることができますが別に無視でもいいです．</p><p>この型に定義されている演算は以下のとおりです．ちなみに，この演算子らを算術演算子といいます．(名前はいちいち覚えなくていいです)</p><table><thead><tr><th>演算子</th><th>意味</th><th>コード例</th><th>結果</th></tr></thead><tbody><tr><td><code>+</code></td><td>和</td><td>3 + 6</td><td>9</td></tr><tr><td><code>-</code></td><td>差</td><td>4 - 1</td><td>3</td></tr><tr><td><code>*</code></td><td>積</td><td>19 * 8</td><td>152</td></tr><tr><td><code>/</code></td><td>商</td><td>9 / 2</td><td>4.5</td></tr><tr><td><code>%/%</code></td><td>整数商 (あまりを無視した商)</td><td>9 %/% 2</td><td>4</td></tr><tr><td><code>%%</code></td><td>剰余 (余り)</td><td>9 %% 2</td><td>1</td></tr><tr><td><code>^</code></td><td>累乗</td><td>2^4</td><td>16</td></tr></tbody></table><p>また，これら値同士を比較する比較演算子というものもあり，これらの演算の結果，後述するLogical型の値を返します</p><table><thead><tr><th>演算子</th><th>意味</th><th>説明</th><th>コード例</th><th>結果</th></tr></thead><tbody><tr><td>==</td><td>同等</td><td>左側と右側の値が等しいかを判定</td><td>1 == 1</td><td>TRUE</td></tr><tr><td>!=</td><td>不等</td><td>左側と右側の値が等しくないかを判定</td><td>1 != 1</td><td>FALSE</td></tr><tr><td>></td><td>大なり</td><td>左側が右側より大きいかを判定</td><td>100 > 101</td><td>FALSE</td></tr><tr><td>>=</td><td>以上</td><td>左側が右側以上かを判定</td><td>100 >= 100</td><td>TRUE</td></tr><tr><td>&lt;</td><td>小なり</td><td>左側が右側より小さいかを判定</td><td>-100 &lt; 100</td><td>TRUE</td></tr><tr><td>&lt;=</td><td>以下</td><td>左側が右側以下かを判定</td><td>100000 &lt; 1</td><td>FALSE</td></tr></tbody></table><h3 id=logicalbool-論理型>Logical(bool, 論理)型
<a class=anchor href=#logicalbool-%e8%ab%96%e7%90%86%e5%9e%8b>#</a></h3><p><code>TRUE</code>,<code>FALSE</code>の二つだけからなる型です．こいつらには論理演算が定義されてます．論理演算って<code>かつ</code>とか<code>または</code>とかいうやつです．論理の正誤を考える時に，非常に役立ちます．</p><table><thead><tr><th>演算子</th><th>意味</th><th>説明</th><th>コード例</th><th>結果</th></tr></thead><tbody><tr><td>|</td><td>論理和</td><td>どちらか一方がTRUEならTRUE</td><td>TRUE | FALSE</td><td>TRUE</td></tr><tr><td>||</td><td>論理和</td><td>どちらか一方がTRUEならTRUE</td><td>FALSE || FALSE</td><td>FALSE</td></tr><tr><td><code>&</code></td><td>論理積</td><td>両方ともTRUEならTRUE</td><td>FALSE & TRUE</td><td>FALSE</td></tr><tr><td><code>&&</code></td><td>論理積</td><td>両方ともTRUEならTRUE</td><td>TRUE && TRUE</td><td>TRUE</td></tr><tr><td><code>!</code></td><td>論理否定</td><td>逆を返す</td><td>!TRUE</td><td>FALSE</td></tr></tbody></table><h3 id=characterstring-文字列型>Character(String, 文字列)型
<a class=anchor href=#characterstring-%e6%96%87%e5%ad%97%e5%88%97%e5%9e%8b>#</a></h3><p>文字列です．Rでは文字列は<code>"ダブルクォーテーション"</code>または<code>'シングルクォーテーション'</code>で囲んで作成できます．日本語も扱えますが，極力，英数字にすることを勧めます．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>greeting <span style=color:#f92672>&lt;-</span> <span style=color:#e6db74>&#34;Hello, world!&#34;</span>
</span></span></code></pre></div><h3 id=factor因子型>Factor(因子)型
<a class=anchor href=#factor%e5%9b%a0%e5%ad%90%e5%9e%8b>#</a></h3><p>因子(Factor)は，Rでカテゴリカルデータ（カテゴリー・分類データ）を扱うためのデータ構造です． 例えば「性別（男性/女性）」や「評価（高/中/低）」などの限定されたカテゴリ（レベル）を持つデータを管理するのに適しています．データ解析の際に各ファクターごとに解析するなど直感的な操作が可能になります．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span><span style=color:#75715e># データ</span>
</span></span><span style=display:flex><span>data <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>(<span style=color:#e6db74>&#34;Male&#34;</span>, <span style=color:#e6db74>&#34;Female&#34;</span>, <span style=color:#e6db74>&#34;Female&#34;</span>, <span style=color:#e6db74>&#34;Male&#34;</span>, <span style=color:#e6db74>&#34;Male&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 因子の作成</span>
</span></span><span style=display:flex><span>gender <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>factor</span>(data)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(gender)
</span></span><span style=display:flex><span><span style=color:#75715e># [1] Male   Female Female Male   Male  </span>
</span></span><span style=display:flex><span><span style=color:#75715e># Levels: Female Male</span>
</span></span></code></pre></div><h3 id=function関数型>Function(関数)型
<a class=anchor href=#function%e9%96%a2%e6%95%b0%e5%9e%8b>#</a></h3><p>詳しくは後述しますが，関数を表した型です．</p><p>他にも様々な型がありますが，一旦これくらいにしておきます．</p><h2 id=データ構造>データ構造
<a class=anchor href=#%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0>#</a></h2><p>これまで型という，値一つ一つが，どの集合に属するかといった話をしてきました．次にデータ構造についてお話しします．値をどのような形式で保管するか，コンピュータ上でデータを扱いやすくするため一定の形式で収納されたデータの構造体のことをデータ構造といいます．何のこっちゃといった感じだと思いますが，実はプログラミングをする上でトップクラスに大事なところです．じっくり勉強しましょう．</p><h3 id=vectorベクター>Vector(ベクター)
<a class=anchor href=#vector%e3%83%99%e3%82%af%e3%82%bf%e3%83%bc>#</a></h3><p>最も基本的かつ，最重要なデータ構造です．同じ型の値が一つ以上格納されているデータ構造です．要するに，同じ型の値を一列に並べたものです．</p><p>以下の例は変数<code>vec</code>に10, 20, 30, 40, 50という値たちを収納したvectorを代入している例です．ベクターを作成するには<code>c</code>関数(cはcombineの頭文字っぽいです)というものの中に作りたいベクターの中身を書きます．個々の値を一列に結合させるイメージです．関数については後述の章を参照してください．
vectorに収められた，値一つ一つに個別にアクセスするには<code>vec[1]</code>のように，前から何個目の値が欲しいかを書く必要があります．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>vec <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#&gt; 10 20 30 40 50</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vec[3] <span style=color:#f92672>==</span> <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#&gt; TRUE</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 連続した値をまとめたいときは,[開始値]:[終了値]のようにかける</span>
</span></span><span style=display:flex><span>vec <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>#&gt; 1 2 3 4 5 6 7 8 9</span>
</span></span></code></pre></div><p>データ解析をする以上，複数の値を保存しておく必要があります．ベクターは，最も単純であるが故に，最も使い道の多く汎用性のあるデータ構造であるといえます．
この後，さまざまなデータ構造を学びますが，本質的にはこのベクターの概念を拡張したものに過ぎません．</p><h3 id=dataframeデータフレーム>Dataframe(データフレーム)
<a class=anchor href=#dataframe%e3%83%87%e3%83%bc%e3%82%bf%e3%83%95%e3%83%ac%e3%83%bc%e3%83%a0>#</a></h3><p>データ解析でよく見るデータ構造です．早い話が，Excelのように表形式になったデータフレームです．
縦の列がベクターとなっている(同じ型)こと，全ての列の値の個数が同じであることが特徴です．
とはいえ，データ解析をする上では後述するtibbleというデータフレームを拡張したデータ構造を使うことが近年一般的になってきています．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>df <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>data.frame</span>(
</span></span><span style=display:flex><span>    Name <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#e6db74>&#34;Charlie&#34;</span>),
</span></span><span style=display:flex><span>    Age <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>22</span>),
</span></span><span style=display:flex><span>    Score <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>85</span>, <span style=color:#ae81ff>88</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(df)
</span></span><span style=display:flex><span><span style=color:#75715e>#      Name Age Score</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1   Alice  24    90</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2     Bob  30    85</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3 Charlie  22    88</span>
</span></span></code></pre></div><h3 id=listリスト>List(リスト)
<a class=anchor href=#list%e3%83%aa%e3%82%b9%e3%83%88>#</a></h3><p>listは一見vectorによく似た，値を一列に並べたデータ構造です．vectorと違う点は，値の型が全て同じでなくていいという点です．いろんな型をごちゃ混ぜに一緒にしておけるデータ構造です．
いろんな型を一気に扱えるならリストの方がいいじゃん，とかListとvector分ける意味あるの?とかお思いになった方もいると思いますが，基本的にデータが厳密であればあるほど計算や演算が楽になります．つまりは，管理の大変さと計算の大変さはトレードオフの関係にあると考えていただければOKです．そのため，それぞれ使い分けが重要です．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>lst <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>list</span>(
</span></span><span style=display:flex><span>    num_vec <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>    df <span style=color:#f92672>=</span> <span style=color:#a6e22e>data.frame</span>(
</span></span><span style=display:flex><span>        Name <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#e6db74>&#34;Charlie&#34;</span>),
</span></span><span style=display:flex><span>        Age <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>22</span>),
</span></span><span style=display:flex><span>        Score <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>85</span>, <span style=color:#ae81ff>88</span>)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># リストの中身を参照</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(lst<span style=color:#f92672>$</span>num_vec)  <span style=color:#75715e># ベクトル</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [1] 1 2 3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(lst<span style=color:#f92672>$</span>df)       <span style=color:#75715e># データフレーム</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#      Name Age Score</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1   Alice  24    90</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2     Bob  30    85</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3 Charlie  22    88</span>
</span></span></code></pre></div><h3 id=tibble型>tibble型
<a class=anchor href=#tibble%e5%9e%8b>#</a></h3><p>tibbleはtidyverseというパッケージ群で提供されている．Dataframeを拡張したデータ構造です．詳しい内容はtidyverseのページをご覧ください．</p><h2 id=制御構文>制御構文
<a class=anchor href=#%e5%88%b6%e5%be%a1%e6%a7%8b%e6%96%87>#</a></h2><p>プログラムは基本的に上から下へ順繰りに書いたものが実行されていきます．しかし，条件によって実行したいプログラムが違ったり，同じ処理を何度もして欲しい時があります．このような処理を記述するために制御構文があります．具体的には条件分岐のための<code>if</code>，反復処理のための<code>for</code>などがあります．</p><p>つまりプログラミングで何ができるかというと，ある型の値を代入し，条件分岐や反復処理などによって計算を繰り返し，得られた結果を出力する作業になっています．</p><h3 id=条件分岐>条件分岐
<a class=anchor href=#%e6%9d%a1%e4%bb%b6%e5%88%86%e5%b2%90>#</a></h3><p>プログラムは上から順番に書いてある順に計算が進んでいきます．条件によって計算の順序や内容を変えたい時に<code>if</code>文を使い条件分岐をすることができます．
例えば，あるテストの得点<code>score</code>に応じて，評価を下すプログラムを書くとします．80点以上なら天才，60点以上なら合格，それ未満なら不合格と判定するプログラムです．
基本的に<code>if (論理式) { 処理内容 }</code>の形で書いていくことになります．論理式の部分について，上で説明した論理型を返す関数や，値同士の比較演算を書く必要があります．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>score <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>78</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (score <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>80</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;天才&#34;</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (score <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>60</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;合格&#34;</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;不合格&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>if (score >= 80)</code>の()の中の部分では，比較演算子を用いて<code>score</code>が80点以上であるとき,TRUEになる演算が書かれています．()の中身がTRUEになった時，{}の内容が実行されます．<code>else if</code>については初めの<code>if ()</code>がFALSEで<code>else if ()</code>の中身がTRUEの時，実行されます．最後の<code>else</code>では上の<code>if</code>や<code>else if</code>が全てFALSEだった時に実行される様になっています．</p><p>条件分岐を書く際には，毎回<code>else if</code>や<code>else</code>を書く必要はなく，例えば例外的な処理をしたい時,<code>if (例外の条件) {例外処理}</code>のように<code>if</code>文だけを書くこともできます，また括弧内の論理式の部分には，論理型の説明にあったように<code>&</code>や<code>|</code>を用いて論理演算を記述することで複雑な条件を表現することもできます．</p><h3 id=反復処理ループ処理>反復処理(ループ処理)
<a class=anchor href=#%e5%8f%8d%e5%be%a9%e5%87%a6%e7%90%86%e3%83%ab%e3%83%bc%e3%83%97%e5%87%a6%e7%90%86>#</a></h3><p>人がプログラムを書くのは反復処理をしたいがためでしょう．反復処理では，同じような計算を繰り返す際に，少ない記述量で書くことができます．
例えば，テストの得点のvector<code>scores</code>が与えられたとします．合格点以上の点数のみを取り出したい時，<code>for</code>文を使って書いてみましょう．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>scores <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>59</span>, <span style=color:#ae81ff>81</span>, <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>45</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (score <span style=color:#66d9ef>in</span> scores) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (score <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>60</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>print</span>(score)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>for文を使わない場合，<code>if (scores[1] >= 60) { ... } if (scores[2] >= 60) ...</code>の様に，同じ内容を繰り返して書くことになります．<code>for</code>文を用いることで繰り返し処理をまとめて書くことができます．<code>for (変数名 in ベクター) { 変数を用いた処理 }</code>の様に記述することができますが，<code>for (変数名 in [開始値]:[終了値])</code>など様々なバリエーションがあります．</p><h2 id=関数>関数
<a class=anchor href=#%e9%96%a2%e6%95%b0>#</a></h2><p>お待たせしました．よく聞いたことあるけど，皆さんの知ってる関数とは少し違うのがプログラミングのおける関数という概念です．</p><p>数学における関数というのは例えば
<link rel=stylesheet href=https://hu-bioinfo.github.io/katex/katex.min.css><script defer src=https://hu-bioinfo.github.io/katex/katex.min.js></script><script defer src=https://hu-bioinfo.github.io/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\( f(x) = 2 x \)
</span>のようにある値から，ある値への対応を示したものです．より厳密な言い方をすれば，ある集合<strong>A</strong>の要素に対し，その要素を入力すると，その要素に対応した集合<strong>B</strong>の特定の要素をただ一つ出力するものを関数といいます．</p><p>一方，プログラミングにおける関数とは，一連の処理をまとめたものです．サブルーチンともいいます．処理をまとめるメリットとして，同じ処理を何度も書かなくてよく，再利用しやすいこと，コードがすっきりと読みやすくなり可読性が向上すること，修正する時，修正箇所が少なく済むなど様々なメリットがあります．
例えば以下の例を見てみましょう．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span><span style=color:#75715e># 3人の従業員のデータ</span>
</span></span><span style=display:flex><span>employee1_base_salary <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>300000</span>
</span></span><span style=display:flex><span>employee1_overtime_hours <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>employee1_bonus <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>50000</span>
</span></span><span style=display:flex><span>employee1_tax_rate <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>0.2</span>
</span></span><span style=display:flex><span>employee1_ovetime_rate <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>2000</span>
</span></span><span style=display:flex><span>employee1_overtime_pay <span style=color:#f92672>&lt;-</span> employee1_overtime_hours <span style=color:#f92672>*</span> employee1_ovetime_rate
</span></span><span style=display:flex><span>employee1_salary_after_tax <span style=color:#f92672>&lt;-</span> (employee1_base_salary <span style=color:#f92672>+</span> employee1_overtime_pay <span style=color:#f92672>+</span> employee1_bonus) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> employee1_tax_rate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>employee2_base_salary <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>400000</span>
</span></span><span style=display:flex><span>employee2_overtime_hours <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>employee2_bonus <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>60000</span>
</span></span><span style=display:flex><span>employee2_tax_rate <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>0.22</span>
</span></span><span style=display:flex><span>employee2_ovetime_rate <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>2500</span>
</span></span><span style=display:flex><span>employee2_overtime_pay <span style=color:#f92672>&lt;-</span> employee2_overtime_hours <span style=color:#f92672>*</span> employee2_ovetime_rate
</span></span><span style=display:flex><span>employee2_salary_after_tax <span style=color:#f92672>&lt;-</span> (employee2_base_salary <span style=color:#f92672>+</span> employee2_overtime_pay <span style=color:#f92672>+</span> employee2_bonus) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> employee2_tax_rate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>employee3_base_salary <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>350000</span>
</span></span><span style=display:flex><span>employee3_overtime_hours <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>employee3_bonus <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>55000</span>
</span></span><span style=display:flex><span>employee3_tax_rate <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>0.21</span>
</span></span><span style=display:flex><span>employee3_ovetime_rate <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>2200</span>
</span></span><span style=display:flex><span>employee3_overtime_pay <span style=color:#f92672>&lt;-</span> employee3_overtime_hours <span style=color:#f92672>*</span> employee3_ovetime_rate
</span></span><span style=display:flex><span>employee3_salary_after_tax <span style=color:#f92672>&lt;-</span> (employee3_base_salary <span style=color:#f92672>+</span> employee3_overtime_pay <span style=color:#f92672>+</span> employee3_bonus) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> employee3_tax_rate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 結果を表示</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(employee1_salary_after_tax)
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(employee2_salary_after_tax)
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(employee3_salary_after_tax)
</span></span></code></pre></div><p>目がチカチカしますね．これを関数を使うことで以下のように書き直すことができます．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span><span style=color:#75715e># 給与を計算する関数</span>
</span></span><span style=display:flex><span>calculate_salary <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>function</span>(base_salary, overtime_hours, overtime_rate, bonus, tax_rate) {
</span></span><span style=display:flex><span>  overtime_pay <span style=color:#f92672>&lt;-</span> overtime_hours <span style=color:#f92672>*</span> overtime_rate
</span></span><span style=display:flex><span>  gross_salary <span style=color:#f92672>&lt;-</span> base_salary <span style=color:#f92672>+</span> overtime_pay <span style=color:#f92672>+</span> bonus
</span></span><span style=display:flex><span>  net_salary <span style=color:#f92672>&lt;-</span> gross_salary <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> tax_rate)
</span></span><span style=display:flex><span>  net_salary
</span></span><span style=display:flex><span>  <span style=color:#75715e># return(net_salary)でも可</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>result_employee1 <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>calculate_salary</span>(employee1_base_salary, employee1_overtime_hours, employee1_ovetime_rate, employee1_bonus, employee1_tax_rate) 
</span></span><span style=display:flex><span>result_employee2 <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>calculate_salary</span>(employee2_base_salary, employee2_overtime_hours, employee2_ovetime_rate, employee2_bonus, employee2_tax_rate)
</span></span><span style=display:flex><span>result_employee3 <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>calculate_salary</span>(employee3_base_salary, employee3_overtime_hours, employee3_ovetime_rate, employee3_bonus, employee3_tax_rate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(result_employee1)
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(result_employee2)
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(result_employee3)
</span></span></code></pre></div><p>上記の例では<code>calculate_salary</code>関数を作成することで，同じような処理をまとめることができました．</p><p>関数を作成する際は<code>関数名 &lt;- function (引数名) { 処理内容 }</code>のように記述します．<code>function</code>キーワードを用いて関数型のオブジェクトを作成し，関数名に代入します．<code>()</code>の中には，関数の入力が入ります．これを<code>引数</code>といいます．<code>{}</code>の中には引数を用いた処理内容を記述します．最終的に関数が返す値は一番最後の行に書いたものが返されます．(<code>return</code>関数を用いて明示的に返すのも可)．これを<code>戻り値(返り値)</code>といいます．</p><p>関数は引数を受け取ることで，決まった一連の処理を少ない記述量で実行できます．そして，便利な関数は他の誰かが作ってくれていることがほとんどです．
具体的には，複数の引数を受け取って<strong>vector</strong>を生成する<code>c</code>関数や，受け取ったものを画面に表示する<code>print</code>関数などがあります．</p><h2 id=予約語>予約語
<a class=anchor href=#%e4%ba%88%e7%b4%84%e8%aa%9e>#</a></h2><p>これまでの制御構文や関数に使われるようなキーワードたち(if, else, function, forなど)は変数として使えません．詳細は<code>?Reserved</code>をR内で実行すると確認できます．</p><h2 id=コメントアウト>コメントアウト
<a class=anchor href=#%e3%82%b3%e3%83%a1%e3%83%b3%e3%83%88%e3%82%a2%e3%82%a6%e3%83%88>#</a></h2><p>コメントアウトは，プログラミングでコードの一部を一時的に無効化したり，注釈を書き込むための方法です． Rでは文頭に<code>#</code>を書くことで，その行が無視されます．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;Hello world&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># print(&#34;この行は実行されない&#34;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 体重(kg)</span>
</span></span><span style=display:flex><span>body_weight <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>60</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 関数の説明: 受け取った値を2倍にする</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 引数:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   x - 数値型</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 戻り値:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   2*x - 数値型</span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>function</span>(x) { <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> x }
</span></span></code></pre></div><p>プログラムを書いていると処理が煩雑になりがちです．後日見返してみると，この変数は何を示した変数なのか，この関数は何の処理を行なっているのか，分からなくなることがよくあります．そのような事態を避けるためにも，説明をコード上に残しておくことが重要です．昨日や明日の自分は他人だと思いましょう．</p><p>また，コードを書き直す際にも一旦コードを削除して一から書き直すのではなく，一部コードをコメントアウトして，そこを参照しながら推敲すると良いでしょう．書き直しがうまくいかない時はコメントアウトを外すだけで元に戻るので．</p><h2 id=パッケージ>パッケージ
<a class=anchor href=#%e3%83%91%e3%83%83%e3%82%b1%e3%83%bc%e3%82%b8>#</a></h2><p>他の誰かが作ってくれた関数やコードの活用方法を学びましょう．他の誰かが作ってくれたコードの塊をパッケージといいます．
パッケージには，Rそのものに備え付けされている標準パッケージと，他の誰かが作ってくれていて自分でインストールする必要のあるパッケージがあります．</p><p>標準パッケージにはベクターやリストを作る<code>c</code>関数や，画面に出力する<code>print</code>関数，二つのベクターを与えればt検定してくれる<code>t.test</code>関数など特に特別な記述を必要とせず使える便利な関数がたくさんあります．</p><p>もう一方のパッケージたちは，世界各国の現場の研究者達やRStudioチームをはじめとするオープンソース開発者達が独自に開発して公開しています．なのでそのコード達を自分たちで手元にインストールする必要があります．公開のされ方には様々ありますが，大体がCRANやGitHubといったサイトからインストールすることになります．CRANは，The Comprehensive R Archive Network（包括的Rアーカイブネットワーク）の略称でRに関するコードとドキュメントを配布しているサーバー群です．GitHubはRに限らず様々なソースコードを保管，共有，公開しているサービスです．</p><p>ここではCRANからパッケージをインストールすることを扱います．<code>install.packages("パッケージ名")</code>を実行し，欲しいパッケージをインストールします．これはインストール時に1回実行するだけで大丈夫です．インストール後は <code>library(パッケージ名)</code>を実行することで，パッケージに含まれる関数を呼び出すことができるようになります．</p><p>パッケージのインストール，管理方法については別のページにて今後立項予定です．</p><p>これらのパッケージは用途ごとに膨大な数があり，何か行いたい処理があるたびに検索など調べ物を繰り返し，使い方を学習していく必要があります．AIを活用して勉強していきましょう．</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#プログラミング言語>プログラミング言語</a></li><li><a href=#変数と代入そして型>変数と代入，そして型</a></li><li><a href=#型>型</a></li><li><a href=#rにおける具体的な型と演算子>Rにおける具体的な型と演算子</a><ul><li><a href=#numeric数値型>Numeric(数値)型</a></li><li><a href=#logicalbool-論理型>Logical(bool, 論理)型</a></li><li><a href=#characterstring-文字列型>Character(String, 文字列)型</a></li><li><a href=#factor因子型>Factor(因子)型</a></li><li><a href=#function関数型>Function(関数)型</a></li></ul></li><li><a href=#データ構造>データ構造</a><ul><li><a href=#vectorベクター>Vector(ベクター)</a></li><li><a href=#dataframeデータフレーム>Dataframe(データフレーム)</a></li><li><a href=#listリスト>List(リスト)</a></li><li><a href=#tibble型>tibble型</a></li></ul></li><li><a href=#制御構文>制御構文</a><ul><li><a href=#条件分岐>条件分岐</a></li><li><a href=#反復処理ループ処理>反復処理(ループ処理)</a></li></ul></li><li><a href=#関数>関数</a></li><li><a href=#予約語>予約語</a></li><li><a href=#コメントアウト>コメントアウト</a></li><li><a href=#パッケージ>パッケージ</a></li></ul></nav></div></aside></main></body></html>