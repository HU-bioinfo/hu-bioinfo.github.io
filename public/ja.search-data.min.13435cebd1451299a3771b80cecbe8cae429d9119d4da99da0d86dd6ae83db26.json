[{"id":0,"href":"/docs/tutorials/","title":"Tutorials","section":"Docs","content":" Tutorials # "},{"id":1,"href":"/docs/tutorials/linux-command/","title":"linux-command","section":"Tutorials","content":" Linuxコマンドの基本 # 1. 最低限必要なコマンド # Linuxの基本操作を行うために、最低限知っておくべきコマンドを紹介します。\n1.1 ファイル・ディレクトリ操作 # ls ：ファイルやディレクトリを一覧表示 cd ：ディレクトリを移動 pwd ：現在のディレクトリを表示 mkdir ：新しいディレクトリを作成 rm ：ファイルやディレクトリを削除 cp ：ファイルやディレクトリをコピー mv ：ファイルやディレクトリを移動 1.2 データ操作 # cat ：ファイルの中身を表示、結合 less ：ファイルの内容をページ送りで表示 grep ：特定の単語を検索して表示 2. 知っておくと便利なコマンド # 基本コマンドに加えて、知っておくと便利なコマンドを紹介します。\n2.1 権限・圧縮・バージョン管理 # chmod ：ファイルの権限を変更 echo ：指定した文字列を標準出力に表示 tar ：アーカイブを作成または展開 git ：バージョン管理システム 2.2 Rスクリプトの実行 # Rscript ：Rスクリプトを実行 3. まとめ # Linuxの基本操作として、ファイル・ディレクトリ操作、データ操作のコマンドを覚えましょう。 さらに、権限変更やアーカイブ操作、バージョン管理、Rスクリプト実行などもできると便利です。 ターミナルを開いて、実際にコマンドを試してみましょう！ "},{"id":2,"href":"/docs/lecture/what-is-rna-seq/","title":"What is RNA-seq?","section":"Lecture","content":" What is RNA-seq？ # はじめに：遺伝子の情報が形になるまで # 私たちの体の設計図であるDNAには、様々なタンパク質を作るための情報が書かれています。しかし、DNAの情報が直接タンパク質になるわけではありません。\nセントラルドグマという生命の基本的な原則があります。これは、遺伝子情報が DNA → RNA → タンパク質 という一方向の流れで伝えられる、という考え方です。\ngraph LR A[DNA] -- Replication --\u003e A A -- Transcription --\u003e B[RNA] B -- Translation --\u003e C[Protein] 転写 (Transcription): DNAの必要な部分の情報が mRNA (メッセンジャーRNA) という分子にコピーされます。 翻訳 (Translation): mRNAの情報をもとに、タンパク質が合成されます。 このタンパク質が、私たちの体の機能や見た目（表現型）を作り出す実働部隊です。つまり、どの遺伝子からどれくらいの量のmRNAが作られるか（遺伝子発現）が、細胞や個体の状態を決定する上で非常に重要なのです。\n**補足:** 実際には、RNAにはmRNA以外にも様々な種類があり、それぞれ重要な役割を担っています。また、セントラルドグマには例外（逆転写など）も存在しますが、まずはこの基本的な流れを理解することが重要です。 RNA-seqとは？ # RNA-seq (RNAシーケンシング) は、細胞の中に存在するRNA、特に mRNA を網羅的に読み取り、その種類と量を調べるための強力な技術です。\nこれにより、特定の時点や条件下で、どの遺伝子が活発に働いているか（発現しているか） を大規模に知ることができます。\nbulk RNA-seq と single-cell RNA-seq # RNA-seqには、大きく分けて2つのアプローチがあります。\nbulk RNA-seq: 複数の細胞の集団からRNAをまとめて抽出し、平均的な発現パターンを解析します。組織全体の傾向を見るのに適しています。 single-cell RNA-seq (scRNA-seq): 細胞を1つずつ分離し、それぞれの細胞のRNAを解析します。細胞ごとの違いや、不均一な細胞集団の内部構造を詳細に調べることができます。 もう少し詳しくデータの性質を見てみましょう。\nbulk RNA-seq では、測定結果は組織や細胞集団全体の 平均的な遺伝子発現 を表します。通常、1人の患者さんや1つの実験条件あたり、1つのサンプル（RNA抽出物）からデータが得られます。 一方 single-cell RNA-seq では、個々の細胞ごと の遺伝子発現プロファイルが得られます。つまり、1人の患者さんや1つのサンプルから、数百〜数万個の細胞（データ点） を得ることができ、細胞間のばらつきや、異なる細胞タイプの存在を直接的に解析できます。 このデータの粒度の違いは、後に行うデータ解析のアプローチにも大きく影響します。\ngraph TD subgraph bulk [\"Bulk RNA-seq\"] direction LR bulk_A[組織/細胞集団] --\u003e bulk_B(まとめてRNA抽出) --\u003e bulk_C{平均的な\\n発現データ\\n(1サンプル)} end subgraph sc [\"Single-cell RNA-seq\"] direction LR sc_D[組織/細胞集団] --\u003e sc_E(1細胞ずつ分離) --\u003e sc_F(...) sc_E --\u003e sc_G(細胞ごとに\\nRNA抽出/解析) --\u003e sc_H{細胞ごとの\\n発現データ\\n(多数の細胞)} end このレクチャーでは、主に **bulk RNA-seq** について解説を進めます。 bulk RNA-seq実験の基本的な流れ # bulk RNA-seqは、一般的に以下のステップで進められます。\nRNA抽出 (RNA Extraction): 解析したい細胞や組織からRNAを抽出します。DNAやタンパク質などの他の分子を取り除き、純粋なRNAを得ることが重要です。 ライブラリ調製 (Library Preparation): 抽出したRNAをシーケンサーで読み取れる形に加工します。 （多くの場合）mRNAの選択またはrRNA（リボソームRNA）の除去 RNAを断片化 cDNA（相補的DNA）への逆転写 アダプター配列の付加（シーケンサーが認識するための目印） PCR増幅 シーケンシング (Sequencing): 調製したライブラリを次世代シーケンサー（NGS）で読み取り、大量の短い塩基配列データ（リード）を得ます。 データ解析 (Data Analysis): 得られたリードをリファレンスゲノムやトランスクリプトームにマッピングし、遺伝子ごとにリード数をカウントすることで、遺伝子の発現量を定量します。その後、統計解析などを行い、実験群間での発現変動などを調べます。 **注意:** 各ステップには細かいプロトコルや注意点が多く存在します。ここでは大まかな流れを理解することを目的としています。 "},{"id":3,"href":"/docs/lecture/","title":"Lecture","section":"Docs","content":" Lecture # What is RNA-seq?\n"},{"id":4,"href":"/docs/tutorials/tidyverse/","title":"Tidyverse","section":"Tutorials","content":" Tidyverse # Tidyverseってなんぞや # Tidyverseは，データ分析と可視化を効率的に行うために設計されたR言語のパッケージ群です． このパッケージの思想上の特徴としてTidy Dataの原則のもと，一貫性のある操作体系により，データ処理の生産性を保つことを特徴としています．\nとはいえ含まれる内容や思想も膨大かつ難解なので，この章では，よくする使い方をメインに書いていきます． より詳しく知りたい方は，それぞれ詳細のページを見てください．(現在製作中です)\nTidyverseのパッケージ群 パッケージ名 役割 主な機能 ggplot2 データ可視化 グラフィックスの文法に基づいて、グラフを宣言的に作成できる dplyr データ操作 フィルタリング，要約，並べ替え，結合といったデータ操作 tidyr データ整理 Tidy data作成 readr データ読み込み 矩形データ（csv、tsv、fwfなど）の高速読み込み purrr 関数型プログラミング ベクトルやリストの操作（map関数など） tibble データフレームの現代的な再構築 モダンなデータフレーム構造 stringr 文字列操作 パターンマッチングや文字列の処理 forcats 因子型操作 因子データのレベルの順序や値の変更など lubridate 日付・時刻データ操作 日付や時間の解析と処理 Tidy Data # 基本的にデータはExcelのように表形式となったデータを扱います．この時，ただ漫然と表を作成するのではなく，一定のルールの下に作成，加工していくことで効率や安全性が増します．具体的なルールとは以下の三つのことです.\n一つの変数は一つの列に（Each variable must have its own column.） 一つの観測は一つの行に（Each observation must have its own row.） 一つの値は一つのセルに（Each value must have its own cell.） 上記3つを満たした表形式のデータを Tidy Data(整列データ) といいます．\n一つの変数は一つの列に（Each variable must have its own column.） # この原則における変数とは，データの特徴を表すものです．人を対象にしたデータだとすると名前，身長，体重，年齢などが該当します．考え方として列では，単位が揃うようなデータにするようにします．例えば，一つの列でcmやkgが同時に登場しないようにします．\n良い例 名前 年齢 身長 (cm) 体重 (kg) 太郎 25 170 65 花子 22 160 50 悪い例 名前 属性 値 太郎 年齢 25 太郎 身長 170 太郎 体重 65 花子 年齢 22 花子 身長 160 花子 体重 50 一つの観測は一つの行に（Each observation must have its own row.） # 観測とは、一つのデータのまとまりのことを指します．人を対象にしたデータだとすると名前がAlice,身長160cm，体重50kg，年齢20歳という一人のデータのことを指します．これらをまとめて一つのデータとして，行単位で追加していきます．\n良い例 名前 年齢 身長 (cm) 体重 (kg) 太郎 25 170 65 花子 22 160 50 悪い例 名前 データ 太郎 25歳 太郎 170cm 太郎 65kg 花子 22歳 花子 160cm 花子 50kg 一つの値は一つのセルに（Each value must have its own cell.） # 各セルに入る値は，一つだけにするという原則です．名前がAliceというデータについて，身長が2つや3つもあるのは不自然ですよね． ただし，Tidyverseで提供されているtibbleというデータフレーム(Excelの表の強化版みたいなもの)は一つのセルの中に,配列を入れることができたり，さらにtibbleを格納することもできるので，必ずしもこの原則が達成されているとは限らないので注意が必要です．\n良い例 名前 好きな食べ物 太郎 寿司 太郎 ラーメン 花子 カレー 花子 パスタ 悪い例 名前 好きな食べ物 太郎 寿司, ラーメン 花子 カレー, パスタ 以上の内容を意識すると，統一的な記述方法でデータを解析，整形することができるので，tidy dataを意識してデータ解析すると良いでしょう．\n余談 Tidy Dataが解析しやすいデータだとすれば，それ以外のデータは解析しずらい，めんどくさいデータです．例え人にとって見やすかったり，扱いやすかったりしてもTidyでないならコンピュータには扱いづらいです．そのため，データを提供する側と解析する側では，往々にしてこの部分ですれ違いがあったりするので，何かデータを扱うときはTidyであるかどうかを気にしてみるといいかもしれません．\nパイプライン演算子 |\u0026gt; # Tidyverseを使用していく上でパイプライン演算子|\u0026gt; を活用することで，処理を簡潔かつ解釈しやすく記述することができます．\n関数 # まず，パイプライン演算子を使う前に，プログラミングにおける関数について説明します．プログラミングにおける関数は，ある処理のまとまりを集めて，いつでも呼び出せるようにしたものです．これは数学における，ある集合からある集合への対応を示す関数とは違い，サブルーチンといった方がより適切です．そのため，処理をまとめただけの関数もあれば，ある入力に対してある出力を返す関数があったりします．\nここで入力に対応するものを引数，出力に対応するものを返り値(戻り値)といいます．\n純粋関数という概念があります．純粋関数とは所謂，数学における関数と等価なもので，ある入力(引数)に対して，いつも同じ出力(返り値)を返す関数です．この純粋関数を組み合わせることでコーディングをしていくのがTidyverseとパイプラインを組み合わせた方法です．\n具体的には純粋関数は，同じ引数に対して，特定の返り値を返すので，ある純粋関数の返り値をそのまま，別の純粋関数の引数に入力することで，処理を記述していきます．これまでのプログラミングといえばやりたいことを逐一丁寧に記述していく手続き型プログラミングといったものを行ってきました．しかし，それとは考え方，アプローチが違ってくるので戸惑う点があるかもしれません．とはいえ，基本的にプログラミングとは何をするかというと，与えられた入力(データ)を加工していく処理，作業に他なりません．その大前提を意識しておけば，どちらもやることがたいして変わりません．以下で具体例を見てみましょう．\n余談 純粋関数とは，ある引数に対して特定の返り値を返す—つまりは引数が同じ時，常に同じ返り値を返すことと，副作用が発生しない関数のことを指します．副作用とは引数以外の入力，返り値以外の出力を伴うことです．具体的には関数の外の変数を参照，変更することであったり，I/O画面やストレージと相互作用をすることを指します．\n例えばprint関数であったり(文字を外部に出力するため), random関数(同じ引数を入力しても出力がランダム)といった関数が非純粋関数となります．\nしかし，Rにおいてそのような関数は大多数を占めますし，本当の意味で純粋関数は少ないのですが，今回は簡単のために上記ような解説となりました．\nパイプライン演算子を使ってみよう # 初めに手続きプログラミング的にコードを書いてみます．以下のコードは，データフレームdfを宣言し，value列の値が20より大きいものを選別し，groupごとに集計し，groupごとの平均値を算出したものを出力するコードです．\nlibrary(dplyr) df \u0026lt;- data.frame( group = c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;), value = c(10, 20, 30, 40, 50) ) temp1 \u0026lt;- filter(df, value \u0026gt; 20) # 20より大きい値をフィルタ temp2 \u0026lt;- group_by(temp1, group) # \u0026#34;group\u0026#34; でグループ化 result \u0026lt;- summarise(temp2, mean_value = mean(value)) # \u0026#34;group\u0026#34;ごとの平均値を計算 print(result) このようなコードでは，変数temp1, temp2のように演算結果を一時的に保存するためだけの変数を宣言したりと無駄が多いです．無駄が多くなると，論理を追いづらくなったり，コードを手直しするにも大変です．\n次の例では一時的な変数を作成しないようにコードを書き直してみます．\nresult \u0026lt;- summarise( group_by(filter(df, value \u0026gt; 20), group), mean_value = mean(value) ) print(result) この書き方では，余計な変数はありませんが，関数の中に関数を書き込んだ形になってしまい，非常に可読性が悪いです．私たちは右から左，外から内に文字を読むのに，処理の流れは左から右に，内から外の順番になってしまっています． ここでパイプライン演算子の出番です．Rのパイプライン演算子|\u0026gt;はある関数の返り値をそのまま，次の関数の第一引数にしてしまいます．\nlibrary(dplyr) df |\u0026gt; filter(value \u0026gt; 20) |\u0026gt; group_by(group) |\u0026gt; summarise(mean_value = mean(value)) |\u0026gt; print() こうすることによって，処理の流れと記述の流れが同じになりました．純粋関数を用いると同じ引数に対し，同じ返り値が帰ってくるので，このような記述が可能になります．\nAdvanced やや発展的な内容になりますが，パイプライン演算子にはRで定義されたnative pipelineと呼ばれる|\u0026gt;とTidyverseのmagrittrパッケージによって提供されている%\u0026gt;%の2種類があります．\nこれらの使い分けとしては，返り値を第一引数ではない場所に用いたい時に，やり方が異なります．%\u0026gt;%では第二引数などに値を渡す時.を使うことで可能になります(place holderといいます)．|\u0026gt;では_を使用しますが，x |\u0026gt; f(100, y=_)のように名前付き引数の時だけ使用できます．\n# place holderは`.`。引数名を指定しなくても良い。 c(\u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;banana\u0026#34;) %\u0026gt;% grepl(\u0026#34;apple\u0026#34;, .) #\u0026gt; TRUE TRUE FALSE # place holderは`_`。引数名を指定しなければいけない。 c(\u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;banana\u0026#34;) |\u0026gt; grepl(\u0026#34;apple\u0026#34;, x = _) #\u0026gt; TRUE TRUE FALSE # 引数名を指定しないとエラーになる。 c(\u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;banana\u0026#34;) |\u0026gt; grepl(\u0026#34;apple\u0026#34;, _) #\u0026gt; Error: pipe placeholder can only be used as a named argument また複数箇所にplace holderを使用したい場合,%\u0026gt;%しか選択肢はありません． とはいえ，基本的には|\u0026gt;の方が高速に動作し，何よりパッケージではなく，R言語そのもので定義されているので，|\u0026gt;を使用するのを個人的には推奨します．\nTidyverseで遊んでみよう # お待たせしました．ここからは実際にcsvデータを加工して，Tidyverseの凄さを思い知りましょう．Tidyverseには多くのパッケージが含まれますが，ここではよく使う，dplyrを中心に使っていきます．\nここで加工していくデータは,dplyr内に練習用として定義されているstarwarsのデータを用います．スターウォーズのキャラクターについての情報が詰まれたデータフレームです． glimpse関数を使用することで，データフレームの概観を知ることができます．(そのままstarwarsと入力するだけでもいいです)\nstarwars |\u0026gt; glimpse() #\u0026gt; Rows: 87 #\u0026gt; Columns: 14 #\u0026gt; $ name \u0026lt;chr\u0026gt; \u0026#34;Luke Skywalker\u0026#34;, \u0026#34;C-3PO\u0026#34;, \u0026#34;R2-D2\u0026#34;, \u0026#34;Darth Vader\u0026#34;, \u0026#34;L… #\u0026gt; $ height \u0026lt;int\u0026gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, … #\u0026gt; $ mass \u0026lt;dbl\u0026gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 84.… #\u0026gt; $ hair_color \u0026lt;chr\u0026gt; \u0026#34;blond\u0026#34;, NA, NA, \u0026#34;none\u0026#34;, \u0026#34;brown\u0026#34;, \u0026#34;brown, grey\u0026#34;, \u0026#34;bro… #\u0026gt; $ skin_color \u0026lt;chr\u0026gt; \u0026#34;fair\u0026#34;, \u0026#34;gold\u0026#34;, \u0026#34;white, blue\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;lig… #\u0026gt; $ eye_color \u0026lt;chr\u0026gt; \u0026#34;blue\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;brown\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;… #\u0026gt; $ birth_year \u0026lt;dbl\u0026gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0, … #\u0026gt; $ sex \u0026lt;chr\u0026gt; \u0026#34;male\u0026#34;, \u0026#34;none\u0026#34;, \u0026#34;none\u0026#34;, \u0026#34;male\u0026#34;, \u0026#34;female\u0026#34;, \u0026#34;male\u0026#34;, \u0026#34;fe… #\u0026gt; $ gender \u0026lt;chr\u0026gt; \u0026#34;masculine\u0026#34;, \u0026#34;masculine\u0026#34;, \u0026#34;masculine\u0026#34;, \u0026#34;masculine\u0026#34;, \u0026#34;… #\u0026gt; $ homeworld \u0026lt;chr\u0026gt; \u0026#34;Tatooine\u0026#34;, \u0026#34;Tatooine\u0026#34;, \u0026#34;Naboo\u0026#34;, \u0026#34;Tatooine\u0026#34;, \u0026#34;Alderaa… #\u0026gt; $ species \u0026lt;chr\u0026gt; \u0026#34;Human\u0026#34;, \u0026#34;Droid\u0026#34;, \u0026#34;Droid\u0026#34;, \u0026#34;Human\u0026#34;, \u0026#34;Human\u0026#34;, \u0026#34;Human\u0026#34;,… #\u0026gt; $ films \u0026lt;list\u0026gt; \u0026lt;\u0026#34;A New Hope\u0026#34;, \u0026#34;The Empire Strikes Back\u0026#34;, \u0026#34;Return of… #\u0026gt; $ vehicles \u0026lt;list\u0026gt; \u0026lt;\u0026#34;Snowspeeder\u0026#34;, \u0026#34;Imperial Speeder Bike\u0026#34;\u0026gt;, \u0026lt;\u0026gt;, \u0026lt;\u0026gt;, \u0026lt;\u0026gt;… #\u0026gt; $ starships \u0026lt;list\u0026gt; \u0026lt;\u0026#34;X-wing\u0026#34;, \u0026#34;Imperial shuttle\u0026#34;\u0026gt;, \u0026lt;\u0026gt;, \u0026lt;\u0026gt;, \u0026#34;TIE Advance… glimpse()を適用すると,行と列がひっくり返ってしまうので注意が必要です．しかし，これでstarwarsが87×14のtibbleで，それぞれの列がどのようなデータを保持しているがわかりました．例えばname列はcharacter(文字列)を保持している列ですね．\nこのようなデータが与えられたときに概観をざっくり知るのは重要です．具体的には行数(レコード数)，列数(特徴量数)，それぞれの列は何を内蔵しているデータなのか，列名と列のデータ型(数値型，文字列型など)に矛盾はないか，データに欠損値はないか，解析の目的にあったデータの内容かといったことを確認するのが重要になります．\n問題1へ 列の操作 # まず初めに列に対する操作です．パイプ演算子|\u0026gt;を使ってselect関数を適用することで，列を抽出できます．rename関数では列名を新しく付け替えることができます．\nstarwars |\u0026gt; select(name, height, homeworld) #name, height, homeworld列だけを抽出 #\u0026gt; # A tibble: 87 × 3 #\u0026gt; name height homeworld #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 Luke Skywalker 172 Tatooine #\u0026gt; 2 C-3PO 167 Tatooine #\u0026gt; 3 R2-D2 96 Naboo #\u0026gt; 4 Darth Vader 202 Tatooine starwars |\u0026gt; select(!starships) # starships以外の列を抽出 #\u0026gt; # A tibble: 87 × 13 #\u0026gt; name height mass hair_color skin_color eye_color birth_year sex gender #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 Luke Sk… 172 77 blond fair blue 19 male mascu… #\u0026gt; 2 C-3PO 167 75 NA gold yellow 112 none mascu… #\u0026gt; 3 R2-D2 96 32 NA white, bl… red 33 none mascu… #\u0026gt; 4 Darth V… 202 136 none white yellow 41.9 male mascu… starwars |\u0026gt; select(ends_with(\u0026#34;color\u0026#34;)) #末尾がcolorで終わる列(hair_color, skin_color, eye_color)を抽出 #\u0026gt; # A tibble: 87 × 3 #\u0026gt; hair_color skin_color eye_color #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 blond fair blue #\u0026gt; 2 NA gold yellow #\u0026gt; 3 NA white, blue red #\u0026gt; 4 none white yellow starwars |\u0026gt; select(where(is.character)) #値が文字列(chr)である列を抽出 #\u0026gt; # A tibble: 87 × 8 #\u0026gt; name hair_color skin_color eye_color sex gender homeworld species #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 Luke Skywalker blond fair blue male mascu… Tatooine Human #\u0026gt; 2 C-3PO NA gold yellow none mascu… Tatooine Droid #\u0026gt; 3 R2-D2 NA white, bl… red none mascu… Naboo Droid #\u0026gt; 4 Darth Vader none white yellow male mascu… Tatooine Human starwars |\u0026gt; select(homeworld) |\u0026gt; # homeworld列を抽出 rename(home_planet = homeworld) # 列名homeworldをhome_planetに変更 #\u0026gt; # A tibble: 87 × 1 #\u0026gt; home_planet #\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 Tatooine #\u0026gt; 2 Tatooine #\u0026gt; 3 Naboo #\u0026gt; 4 Tatooine #\u0026gt; 5 Alderaan 問題2へ 問題4へ 行の操作 # slice_*系の関数は行の操作に使います．slice関数は指定した行番号の列を，slice_head,slice_tailはそれぞれ最初のn行と最後のn行を，slice_min, slice_maxは指定して列の値が小さい順ないし大きい順にn行抽出します．\nfilter関数は何かの条件と合致する(あるいは合致しない)行のみ抽出する関数です． arrange関数はソート関数です．\nstarwars |\u0026gt; select(name, homeworld) |\u0026gt; # name, homeworld列だけ抽出 filter(homeworld == \u0026#34;Tatooine\u0026#34;) |\u0026gt; # homeworldがTatooineの行のみを抽出 slice_head(n = 4) # そのうち先頭4行だけ抽出 #\u0026gt; # A tibble: 4 × 2 #\u0026gt; name homeworld #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 Luke Skywalker Tatooine #\u0026gt; 2 C-3PO Tatooine #\u0026gt; 3 Darth Vader Tatooine #\u0026gt; 4 Owen Lars Tatooine starwars |\u0026gt; select(name, height, homeworld) |\u0026gt; # name,height,homeworld列だけ抽出 filter(homeworld != \u0026#34;Tatooine\u0026#34;) |\u0026gt; # homeworldがTatooineでない行を抽出 slice_max(height, n = 3) # そのうちheightが大きい順に3行抽出 #\u0026gt; # A tibble: 3 × 3 #\u0026gt; name height homeworld #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 Yarael Poof 264 Quermia #\u0026gt; 2 Tarfful 234 Kashyyyk #\u0026gt; 3 Lama Su 229 Kamino starwars |\u0026gt; select(name, hair_color, height, mass) |\u0026gt; # name, height, sex, homeworld列を抽出 filter(!is.na(mass), height \u0026gt;= 100, hair_color == \u0026#34;blond\u0026#34;) |\u0026gt; # massが欠損値がなくて，尚且つheightが100以上かつ，hair_colorがblondの行を抽出 arrange(mass) # massが昇順になるようにソート #\u0026gt; # A tibble: 2 × 4 #\u0026gt; name hair_color height mass #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; #\u0026gt; 1 Luke Skywalker blond 172 77 #\u0026gt; 2 Anakin Skywalker blond 188 84 問題3へ データの要約 # summarise関数を使うと変数の平均値や標準偏差などの記述統計量(要約統計量)を計算できます. group_by関数と組み合わせることで値ごとの記述統計量を出すことができます．\nstarwars |\u0026gt; group_by(homeworld) |\u0026gt; # homeworldごとに集計 summarise( height_mean = mean(height, na.rm = TRUE), #欠損値を除外してheightの平均を計算 mass_mean = mean(mass, na.rm = TRUE), #欠損値を除外してmassの平均を計算 ) #\u0026gt; # A tibble: 49 × 3 #\u0026gt; homeworld height_mean mass_mean #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; #\u0026gt; 1 Alderaan 176. 64 #\u0026gt; 2 Aleen Minor 79 15 #\u0026gt; 3 Bespin 175 79 #\u0026gt; 4 Bestine IV 180 110 問題7へ データの拡張 # mutate関数はtibble内の変数を用いて計算を行い，その結果を新しい列として追加する関数です．\nstarwars |\u0026gt; select(name, height) |\u0026gt; mutate(height_M = height / 100) # heightを100でわりm換算したものをheight_in_mとした #\u0026gt; # A tibble: 87 × 3 #\u0026gt; name height height_M #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; #\u0026gt; 1 Luke Skywalker 172 1.72 #\u0026gt; 2 C-3PO 167 1.67 #\u0026gt; 3 R2-D2 96 0.96 #\u0026gt; 4 Darth Vader 202 2.02 starwars |\u0026gt; select(name, height, mass) |\u0026gt; mutate(height_M = height / 100, BMI = mass / height_M / height_M) |\u0026gt; # heightを100でわりm換算したものをheight_in_mとした mutate(is_obesity = if_else(BMI \u0026gt;= 25, true=\u0026#34;obesity\u0026#34;, false=\u0026#34;not_obesity\u0026#34;)) # if_else関数を用いると,条件を指定して値を指定できる #\u0026gt; # A tibble: 87 × 6 #\u0026gt; name height mass height_M BMI is_obesity #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 Luke Skywalker 172 77 1.72 26.0 obesity #\u0026gt; 2 C-3PO 167 75 1.67 26.9 obesity #\u0026gt; 3 R2-D2 96 32 0.96 34.7 obesity #\u0026gt; 4 Darth Vader 202 136 2.02 33.3 obesity #\u0026gt; 5 Leia Organa 150 49 1.5 21.8 not_obesity 問題5へ 練習問題 # 以下は練習問題です．これまで学習してきたこと＋αな内容ですので，適宜，chatGPTに聞いてみたり調べたりしながら解いてみてください．\n問題1 # starwars データセットの構造を確認せよ。\n💡 ヒント: glimpse(), head(), dim() などを使う\n参考\nAnswer starwars |\u0026gt; glimpse() starwars |\u0026gt; head() starwars |\u0026gt; dim() 問題2 # name, height, mass, homeworld の4列のみを選択し，キャラクターを mass の降順で並べ替えよ．\n💡 ヒント: arrange関数と，desc関数について調べてみよう\n列の操作\nAnswer starwars |\u0026gt; select(name, heightm, mass, homeworld) |\u0026gt; arrange(desc(mass)) 問題3 # starwarsデータセットのうち，gender が \u0026ldquo;masculine\u0026rdquo; かつ mass (体重) が 80kg 以上のキャラクターを抽出せよ\n💡 ヒント: filter関数について調べてみよう\n行の操作\nAnswer starwars |\u0026gt; filter(gender == \u0026#34;masculine\u0026#34;, mass \u0026gt;= 80) 問題4 # nameと列名にアンダーバー _を含む列のみを選択せよ\n💡 ヒント: select, contains関数の使い方を調べてみよう\n列の操作\nAnswer starwars |\u0026gt; select(name, contains(\u0026#34;_\u0026#34;)) 問題5 # birth_year が 100 より大きい場合は \u0026ldquo;Old\u0026rdquo;、それ以外は \u0026ldquo;Young\u0026rdquo; とする age_category という新しい列を作成せよ\n💡 ヒント: if_else関数の使い方を調べてみよう\nデータの拡張\nif_else関数\nAnswer starwars |\u0026gt; mutate(age_category = if_else(birth_year \u0026gt; 100, \u0026#34;Old\u0026#34;, \u0026#34;Young\u0026#34;)) 問題6 # 以下のルールに基づいて weight_category という新しい列を作成せよ。\nmass が 100 kg 以上なら \u0026ldquo;Heavy\u0026rdquo; mass が 50 以上 100 未満なら \u0026ldquo;Medium\u0026rdquo; mass が 50 未満なら \u0026ldquo;Light\u0026rdquo; mass が NA の場合は \u0026ldquo;Unknown\u0026rdquo; 💡 ヒント: case_when関数の使い方を調べてみよう\ncase_when関数\nAnswer starwars |\u0026gt; mutate(weight_category = case_when( is.na(mass) ~ \u0026#34;Unknown\u0026#34;, mass \u0026gt;= 100 ~ \u0026#34;Heavy\u0026#34;, mass \u0026gt;= 50 ~ \u0026#34;Medium\u0026#34;, TRUE ~ \u0026#34;Lignt\u0026#34; )) 問題7 # species ごとに、\nキャラクター数 (n()) height の平均 (mean(height, na.rm = TRUE)) mass の平均 (mean(mass, na.rm = TRUE)) を求めよ。 ただし、キャラクター数が 3 人未満の種族は除外せよ。\n💡 ヒント: group_by, summarise, filter関数の使い方を調べてみよう\nデータの要約\nAnswer starwars |\u0026gt; group_by(species) |\u0026gt; summarise( N = n(), height_mean = mean(height, na.rm = TRUE), mass_mean = mean(mass, na.rm = TRUE) ) |\u0026gt; filter(N \u0026gt; 3) 問題8 # NA を含む数値型の列をすべて選択し、それらの NA を 0 に置き換えよ。\n💡 ヒント: mutate, across, where関数の使い方を調べてみよう. Rにおける無名関数について調べてみよう\nAnswer starwars |\u0026gt; mutate(across(where(is.numeric), ~ replace(., is.na(.), 0))) "},{"id":5,"href":"/docs/tutorials/ggplot2/","title":"ggplot2","section":"Tutorials","content":" ggplot2で作る魅力的なグラフ # このガイドでは、Rのggplot2パッケージを用いて、シンプルかつ柔軟にグラフを作成する方法を紹介します。基本的な使い方から、グラフのカスタマイズ、複数の具体例を通して実際に使えるコードを掲載しています。なお、ここではdplyrの基本的なコマンド（パイプ(|\u0026gt;)、select、filterなど）は既にご存知であるものとして解説します。\n1. ggplot2の基本構造 # ggplot2では、まずデータフレームを指定し、aes()関数で美的属性（x軸、y軸、色、サイズなど）を設定します。その後、geom_系列の関数で具体的なグラフの種類を指定します。\n基本構造は以下の通りです。\nlibrary(ggplot2) ggplot(data = データ, aes(x = x軸, y = y軸)) + geom_○○() 2. 具体例 # 2.1 散布図の作成 # irisデータセットを用い、Sepal.LengthとSepal.Widthの散布図を作成。種別（Species）ごとに色分けして表示します。\nlibrary(dplyr) library(ggplot2) iris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point(size = 3) + labs(title = \u0026#34;Irisデータセットの散布図\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) + theme_minimal() 2.2 ヒストグラムの作成 # irisデータセットのSepal.Lengthの分布をヒストグラムで表示し、Speciesごとに色分けします。\niris |\u0026gt; ggplot(aes(x = Sepal.Length, fill = Species)) + geom_histogram(bins = 30, alpha = 0.7, position = \u0026#34;identity\u0026#34;) + labs(title = \u0026#34;Iris: Sepal.Lengthのヒストグラム\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;度数\u0026#34;) + theme_classic() 2.3 箱ひげ図の作成 # mtcarsデータセットを利用し、シリンダー数（cyl）ごとに燃費（mpg）の箱ひげ図を作成します。\nmtcars |\u0026gt; ggplot(aes(x = factor(cyl), y = mpg, fill = factor(cyl))) + geom_boxplot() + labs(title = \u0026#34;mtcars: シリンダー数ごとの燃費\u0026#34;, x = \u0026#34;シリンダー数\u0026#34;, y = \u0026#34;燃費 (mpg)\u0026#34;) + theme_light() 2.4 線グラフと回帰直線 # 散布図に回帰直線を追加し、データの傾向を視覚化します。\niris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + geom_smooth(method = \u0026#34;lm\u0026#34;, se = FALSE, color = \u0026#34;red\u0026#34;) + labs(title = \u0026#34;Irisデータセット: 回帰直線付き散布図\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) + theme_bw() 2.5 Facetによるパネル分割 # facet_wrapを使用して、Speciesごとにパネルを分割して表示します。\niris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point(size = 2) + facet_wrap(~ Species) + labs(title = \u0026#34;Irisデータセット: 種別ごとの散布図\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) + theme_minimal() 3. グラフのカスタマイズ # 3.1 テーマの変更 # ggplot2には、グラフの見た目を変えるためのテーマが複数用意されています。例えば、theme_minimal() や theme_classic() を使ってシンプルなデザインに変更できます。\nggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + theme_minimal() + labs(title = \u0026#34;Minimalテーマの散布図\u0026#34;) 3.2 ラベルやタイトルの追加 # labs() 関数を使って、タイトルや軸ラベルを設定できます。\nggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + labs(title = \u0026#34;散布図タイトル\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) 3.3 その他のカスタマイズ # 色やサイズ、透明度の調整：各geom関数内で引数を指定することで簡単に変更可能です。 スケールの調整：scale_x_continuous() や scale_color_manual() などを使用して、軸の目盛りやカラーパレットを調整できます。 4. まとめ # ggplot2は、シンプルなコードで高度なグラフ作成が可能な非常にパワフルなツールです。ここで紹介した基本例をもとに、データに合わせたカスタマイズや複雑なグラフの作成に挑戦してみてください。各種テーマやラベルの調整を駆使して、自分のデータを魅力的に可視化しましょう！\n演習問題 # 以下の7問の演習問題に挑戦してみましょう。各問題の答えは、トグルで表示されるようになっています。\n基本的な散布図\nirisデータセットを使用して、Sepal.LengthとSepal.Widthの散布図を作成するコードを書いてください。 答えを見る library(ggplot2) iris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + labs(title = \u0026#34;基本散布図\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) ヒストグラム\nirisデータセットで、Sepal.Lengthのヒストグラムを作成し、Speciesで色分けするコードを書いてください。 答えを見る library(ggplot2) iris |\u0026gt; ggplot(aes(x = Sepal.Length, fill = Species)) + geom_histogram(bins = 30, alpha = 0.6, position = \u0026#34;identity\u0026#34;) + labs(title = \u0026#34;ヒストグラム\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;度数\u0026#34;) 箱ひげ図\nmtcarsデータセットを使用して、cyl（シリンダー数）ごとにmpgの箱ひげ図を作成するコードを書いてください。 答えを見る library(ggplot2) mtcars |\u0026gt; ggplot(aes(x = factor(cyl), y = mpg, fill = factor(cyl))) + geom_boxplot() + labs(title = \u0026#34;箱ひげ図\u0026#34;, x = \u0026#34;シリンダー数\u0026#34;, y = \u0026#34;燃費 (mpg)\u0026#34;) 回帰直線の追加\n散布図に回帰直線を追加するコードを書いてください。 答えを見る library(ggplot2) iris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + geom_smooth(method = \u0026#34;lm\u0026#34;, se = FALSE, color = \u0026#34;red\u0026#34;) + labs(title = \u0026#34;回帰直線付き散布図\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) Facetプロット\nirisデータセットを種別ごとに分割した散布図を作成するコードを書いてください。 答えを見る library(ggplot2) iris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point() + facet_wrap(~ Species) + labs(title = \u0026#34;Facetプロット\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) テーマの変更\ntheme_minimal() を使用してグラフのテーマを変更するコードを書いてください。 答えを見る library(ggplot2) iris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + theme_minimal() + labs(title = \u0026#34;Minimalテーマの散布図\u0026#34;) ラベルの追加\nグラフにタイトル、x軸、y軸のラベルを追加するコードを書いてください。 答えを見る library(ggplot2) iris |\u0026gt; ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + labs(title = \u0026#34;散布図タイトル\u0026#34;, x = \u0026#34;がく片の長さ\u0026#34;, y = \u0026#34;がく片の幅\u0026#34;) ``` "},{"id":6,"href":"/docs/about/","title":"About","section":"Docs","content":"私たちは北海道大学医学部に在学する学生によって構成されている学生団体です. バイオインフォマティクスや広く情報科学ついて学習し合っている団体です．\n"},{"id":7,"href":"/docs/members/","title":"Members","section":"Docs","content":"Comming soon\u0026hellip;\n"},{"id":8,"href":"/docs/tutorials/example/","title":"Example","section":"Tutorials","content":" Example # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nCode example # def main(): print(\u0026#34;Hello wold\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Tex example # 数式もかけるよ: \\(\\int_{-\\infty}^{\\infty}e^{-t^2}dt=\\pi.\\) \\[ \\int_{-\\infty}^{\\infty}e^{-t^2}dt=\\pi. \\] Image example # "},{"id":9,"href":"/docs/how_to_write_articles/","title":"How to Write Articles","section":"Docs","content":" 記事の投稿方法 # 構成 # サイトはHugoのHugo-bookテーマ用いて作成しました． ディレクトリ構成は以下のとおりです． 基本的にいじるのはcontent以下のディレクトリだけです．\n. ├── archetypes ├── config └── _default ├── hugo.toml └── params.toml ├── content ├── docs │ ├── tutorials │ │ ├── example │ │ │ ├── bioinfo_tutorial.webp │ │ │ └── index.md │ │ ├── test │ │ │ └── index.md │ │ ├── _index.md │ │ └── bioinfo_tutorial.webp │ ├── about.md │ └── members.md └── _index.md ├── data ├── i18n ├── layouts ├── public ├── resources ├── static ├── go.mod └── go.sum 記事の作成 # まず，Githubリポジトリのmainブランチをローカルにcloneしてください． 自分で新しい記事を作成，修正するときは，mainではない別のブランチ(自分の名前とか)を作成し，そこで作業するようにしてください．\n今後は基本的にcontent/docs/tutorials以下に，一記事ずつディレクトリを作成していきます．\n├── content ├── docs │ ├── tutorials │ │ ├── new_article │ │ │ ├── images │ │ │ └── index.md 作成したい記事のディレクトリを作成し，index.mdを作り，編集します．\nindex.mdにはヘッダーとして以下のものをつけてください．\n--- title: \u0026#34;Example\u0026#34; weight: 1 # bookFlatSection: false # bookToc: true # bookHidden: false # bookCollapseSection: false # bookComments: false # bookSearchExclude: false --- このときtitleにはディレクトリ名と同じ名前を基本的にはつけてください． weightはサイトの左側メニューに表示される時の順番を示しています．上に載せたいものほど小さい値をつけてください． 挿入する画像は，作成したディレクトリ以下に配置してください．\nmarkdownの編集方法については，Hugo-bookのサイトのShortcodesや，私が作成した記事とサイトを見比べてみてください．\n投稿方法 # 記事の作成が完了したら，git add \u0026amp;\u0026amp; git commitして，リポジトリにそのまま自分のブランチをpushしてください．\npushした自分のブランチをmainブランチに向けてプルリクエストを作成してください．\n無事，プルリクが受理され，mainブランチにマージされたら，Github Actionsが走り，hugoによりサイトがビルドされます． 北大バイオインフォのサイトに変更がなされているか確認してみてください．\nリンク # Githubリポジトリ Github pages Hugo-book "},{"id":10,"href":"/news/%E7%AC%AC1%E5%9B%9E%E5%8B%89%E5%BC%B7%E4%BC%9A%E3%82%84%E3%82%8A%E3%81%BE%E3%81%99/","title":"第1回勉強会やります","section":"News","content":" 第1回勉強会のお知らせ # 開催日時 # 5月13日(火曜日) 17:00\n場所 # 医図書\n(人数が増えればセミナー室を使うかもしれません！)\n内容 # 解析環境の導入\nプログラミング初めての人でも大丈夫です！お気軽にご参加ください！\n"},{"id":11,"href":"/news/test/","title":"Test","section":"News","content":" テスト # monul # エラーメッセージから、Hugoモジュールの取得に失敗していることがわかりますね。具体的には、github.com/HU-bioinfo/hugo-book を取得しようとした際に、そのモジュールの go.mod ファイルが自身のパスを github.com/alex-shpak/hugo-book と宣言しているため、不一致が起こっています。\nwow # 考えられる原因\nこのエラーの主な原因は、取得しようとしているモジュールのパス (github.com/HU-bioinfo/hugo-book) が、実際にモジュールが自身を宣言しているパス (github.com/alex-shpak/hugo-book) と異なっていることです。\n考えられる状況としては、以下のものがあります。\nリポジトリの移動または名前の変更: 元々 github.com/alex-shpak/hugo-book というパスで公開されていたリポジトリが、何らかの理由で github.com/HU-bioinfo/hugo-book というパスに変更された可能性があります。しかし、go.mod ファイル内の宣言は古いパスのままになっているため、不整合が起きています。 "}]